<html>
<head>
<meta charset='utf-8'/>
</head>
<body>
<div class="sigma" id="sigma-container-2015"></div>
2015
<div class="sigma" id="sigma-container-2017"></div>
2017
<script src="js/sigma.js"></script>
<script src="plugins/sigma.parsers.json.min.js"></script>
<script src="plugins/sigma.neo4j.cypher.min.js"></script>
<script src="plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="plugins/sigma.layout.noverlap.min.js"></script>
<script src="plugins/sigma.plugins.animate.min.js"></script>
<style type="text/css">

        /* Set a height on the div or it will have zero height */
        .sigma {
            width: 50%;
            height: 50%;
            margin-top:20px;

        }
        div {
          display:block;
          border-style: solid;
        }

    </style>
<script>
  var xKeep = {};
  var yKeep = {};
  var cont = [];
  var ids = {};
  function graphstart(s) {
    //Params for Directed graph with visible edges
    s.settings('defaultEdgeType', 'arrow');
    s.settings('minArrowSize', 100);
    //Camera for recentering on node after click
    s.addCamera('cam0');
    var listener = s.configNoverlap({nodeMargin: 1, scaleNodes: 1.05, gridSize: 75, duration: 1});
    var focus;
      // We first need to save the original colors of our
      // nodes and edges, like this:
      s.graph.nodes().forEach(function(n) {
        n.originalColor = n.color;
        n.label = n.neo4j_data['name'];
        s.refresh();
      });
      s.graph.edges().forEach(function(e) {
        e.originalColor = e.color;
      });
      s.startForceAtlas2({
            linLogMode: true,
            outboundAttractionDistribution: !1,
            adjustSizes: false,
            edgeWeightInfluence: 0,
            scalingRatio: 0.5,
            strongGravityMode: !1,
            gravity: 1,
            barnesHutOptimize: false,
            barnesHutTheta: 0.5,
            slowDown: 1,
            startingIterations: 1,
            iterationsPerRender: 1,
            worker: true
        });
      s.startNoverlap();
      s.bind('overNode',function(e) {
        //if a node is hovered, stop Forces from calculating
        s.stopForceAtlas2();
      });
      s.bind('clickNode', function(e) {
        var nodeId = e.data.node.id,
            toKeep = s.graph.neighbors(nodeId);
        toKeep[nodeId] = e.data.node;

        s.graph.nodes().forEach(function(n) {
          ids[n.id] = n;
          if (toKeep[n.id])
            n.color = n.originalColor;
          else{
            n.color = '#eee';
            }
          if (n.id == nodeId){
            focus = n;
            s.cameras[0].goTo({x:focus['read_cam0:x'],y:focus['read_cam0:y'],ratio:0.55});
            cont.forEach(function(si){
              if (si != s){
                si.graph.nodes().forEach(function(nn){
                    if (nn.label == n.label && !ids[nn.id]){
                      ids[nn.id] = nn;
                      var ev = e;
                      ev.data.node = nn;
                      si.dispatchEvent('clickNode',ev.data);
                      // si.cameras[0].goTo({x:nn['read_cam0:x'],y:nn['read_cam0:y'],ratio:0.55});
                    }
                });

              }
            });

          }
        });

        s.graph.edges().forEach(function(e) {
          if (toKeep[e.source] && toKeep[e.target])
            e.color = e.originalColor;
          else
            e.color = '#eee';
        });

        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        s.refresh();
        ids = [];
      });
      s.bind('clickStage', function(e) {
        cont.forEach(function(si){
            si.graph.nodes().forEach(function(n) {
              n.color = n.originalColor;
              if (focus != null){
                      si.cameras[0].goTo({x:0,y:0,ratio:1});
                  }

              });
              si.graph.edges().forEach(function(e) {
                e.color = e.originalColor;
              });
        focus = null;
    });

      s.refresh();
      });
    }
  // Add a method to the graph model that returns an
  // object with out neighbors of a node inside:
  sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
        neighbors = {},
        index = this.outNeighborsIndex[nodeId] || {};

    for (k in index)
      neighbors[k] = this.nodesIndex[k];

    return neighbors;
  });


  //TODO: Automatize this with GetLabels and query every single graph within a new container each time
  sigma.neo4j.cypher(
  { url: 'http://0.0.0.0:7474', user: 'neo4j', password: '87cEbq9d' },
  'MATCH (n:Node2015) OPTIONAL MATCH (n)-[r]->(m) RETURN n,r,m',
  { container: 'sigma-container-2015'},
    function(s){
      cont[0] = s;
      graphstart(s);
    });
  sigma.neo4j.cypher(
  { url: 'http://0.0.0.0:7474', user: 'neo4j', password: '87cEbq9d' },
  'MATCH (n:Node2017) OPTIONAL MATCH (n)-[r]->(m) RETURN n,r,m',
  { container: 'sigma-container-2017'},
    function(s){
      cont[1] = s;
      graphstart(s);
    });
  // Calling neo4j to get all its relationship type
sigma.neo4j.getTypes(
        { url: 'http://0.0.0.0:7474', user:'neo4j', password:'87cEbq9d' },
        function(rel) {
            console.log("Relationship types " + rel);
        }
);
// Calling neo4j to get all its node label
sigma.neo4j.getLabels(
        { url: 'http://0.0.0.0:7474', user:'neo4j', password:'87cEbq9d' },
        function(labels) {
            console.log("Node labels " + labels);
        }
);
</script>
</body>
</html>
